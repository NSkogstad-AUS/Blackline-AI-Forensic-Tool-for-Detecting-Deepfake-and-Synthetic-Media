Minimal Metadata Analysis Plan (priority-ordered)

1) Identify & freeze identity
- Record: asset_id, sha256, stored_path, store_root, mime, when, tool_versions.ingest
- Output: Identity block (no comparisons yet).

2) Container sanity (single source of truth = probe.format)
- Read: probe.format.{format_name, format_long_name, nb_streams, duration, size, bit_rate, probe_score} and probe.format.tags.{major_brand, minor_version, compatible_brands, encoder}
- Checks:
  - nb_streams > 0 (else FAIL)
  - probe_score high enough (e.g., ≥50 → OK, else WARN)
  - Container/brands coherent with mime (mismatch → WARN)

3) Pick the primary video stream once
- Select first probe.streams where codec_type=="video" (prefer disposition.default==1). Call it v.
- Stash: v.{index, codec_name, codec_long_name, profile, level, width, height, coded_width, coded_height, pix_fmt, field_order, chroma_location, has_b_frames, refs, is_avc, nal_length_size, extradata_size}.

4) Timing and frame rate consistency (no double counting)
- Use only: v.avg_frame_rate (primary), fallback v.r_frame_rate; v.nb_frames; probe.format.duration.
- Compute fps = parse_fraction(v.avg_frame_rate or v.r_frame_rate).
- Checks:
  - |v.nb_frames - fps*duration| / max(1, fps*duration) ≤ 0.02 → else WARN_TIMING
  - avg_frame_rate ≈ r_frame_rate (if not, WARN_VFR)
  - v.start_time≈0 (|start|≤0.5s) and sane v.time_base (wild values → WARN_TIMEBASE)

5) Geometry & aspect ratio coherence
- Use: v.{width,height,sample_aspect_ratio,display_aspect_ratio}, exif.{ImageWidth,ImageHeight,PixelAspectRatio,Rotation}.
- Compute expected DAR = (width/height) × (sample_aspect_ratio or 1).
- Checks:
  - Expected DAR ≈ display_aspect_ratio (else WARN_DAR)
  - (width,height) ≈ (exif.ImageWidth, exif.ImageHeight) after applying Rotation if 90/270 (else WARN_DIMENSIONS)
  - coded_* ≥ displayed dims (violations → WARN_CROPPING)

6) Codec/GOP plausibility (by codec_name; example: H.264)
- H.264: profile/level suited to width×height×fps; has_b_frames=0 on “High” or bizarre refs → WARN_GOP
- is_avc and nal_length_size consistent (incoherent → WARN_BITSTREAM)
- pix_fmt reasonable for codec (odd combos → WARN_PIXFMT)

7) Bitrate realism (one comparison only)
- Use: v.bit_rate (if missing, use probe.format.bit_rate).
- Heuristic: compare to expected range for res×fps×codec; if << floor or >> ceiling → WARN_BITRATE.

8) Audio streams quick sanity (if present)
- For each audio stream a: stash a.{codec_type, sample_rate, channels, channel_layout, bits_per_sample}.
- Check plausible sample_rate ∈ {44100,48000} and channels ∈ {1,2}; weird layouts → WARN_AUDIO.
- Optionally one compare to exif.{AudioSampleRate,AudioChannels,BitsPerSample}.

9) Provenance & re-encode fingerprints (do once)
- Use: probe.format.tags.encoder, probe.streams.tags.{handler_name,vendor_id,language}, exif.{Encoder,HandlerDescription,HandlerVendorID}.
- Flag known transcoders (Lavf, HandBrake, ffmpeg) when device-original is claimed → WARN_TRANSCODE.
- Implausible handler/vendor strings → WARN_HANDLER.

10) Timestamp monotonicity (minimal, high-value set)
- Use: exif.{FileCreateDate,FileModifyDate}, exif.{CreateDate,ModifyDate,MediaCreateDate,TrackCreateDate}, exif.Duration.
- Checks: FileCreateDate ≤ MediaCreateDate ≤ ModifyDate ≤ now (violations → WARN_DATES).
- exif.Duration ≈ probe.format.duration (else WARN_DURATION).

11) One cross-check bundle (no more)
- Dimensions: exif.ImageWidth/Height ≈ v.width/height (with rotation) — don’t repeat elsewhere.
- Frame rate: if present exif.VideoFrameRate ≈ computed fps (else WARN_FPS_TAG).
- Average bitrate: exif.AvgBitrate ≈ probe.format.bit_rate (tolerance ~10–15%).

12) Dispositions & flags (scan once)
- Read: v.disposition.* (forced, attached_pic, timed_thumbnails, captions).
- If unexpected flags are set (e.g., attached_pic in a camera clip) → WARN_DISPOSITION.

13) Summarize & score
- Build summary using fields: summary.{width,height,fps,codec,duration_s,nb_streams}.
- Collect all WARN_/FAIL_ items with short reasons; compute suspicion score: FAIL=2, WARN=1, OK=0.
- Output JSON blocks: identity, container, video, audio[], provenance, checks[], score, summary.

Copilot one-liner:
Implement the 13-step metadata analyzer exactly as listed, selecting one primary video stream, using only the specified fields per step, and emitting PASS/WARN/FAIL reasons with a final suspicion score and compact summary JSON.
